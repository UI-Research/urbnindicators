#' @title Document variables from [compile_acs_data()]
#' @description `generate_codebook()` returns a codebook for variables returned
#' from `compile_acs_data()`.
#' @details Generates a tibble of variable names and definitions that describe
#' how each variable was created. `generate_codebook()` is called behind the scenes
#' as part of `compile_acs_data()` and the resulting codebook is attached as an attribute
#' to the output; it can be accessed via `compile_acs_data() %>% attr("codebook")`.
#' @param variables A vector of column names. Column names that are not generated
#' by `compile_acs_data()` are returned in the codebook with missing definitions.
#' @param years A character vector (or coercible to the same) comprising one or more
#'    four-digit years for which to pull variable definitions.
#' @seealso [compile_acs_data()], which automatically returns the
#' results of `generate_codebook()` attached to the primary data ouput.
#' @returns A tibble containing the names and definitions of  the variables
#' passed to `variables`. When variables have different definitions across years,
#' each variable is reflected more than once in the codebook. When a variable has
#' a consistent definition across years, it is only represented once. Column names
#' passed to `variables` that are not generated by `compile_acs_data()` are returned
#' in the codebook with missing definitions.
#' @examples
#' df = compile_acs_data(
#'   variables = list_acs_variables(year = 2022),
#'   years = c(2022),
#'   geography = "county",
#'   states = "NJ",
#'   counties = NULL,
#'   retain_moes = TRUE)
#' codebook = generate_codebook(
#'   variables = colnames(df %>% dplyr::select(-matches("percent"))),
#'   years = c(2022))
#' @export
#' @importFrom magrittr %>%
generate_codebook = function(variables = NULL, years = NULL)  {

  if (length(years) == 0) { stop("A value for the `years` parameter is required.") }

  if (length(variables) == 0) { stop("A value for the `variables` parameter is required.") }

  generate_single_year_codebook = function(year, variables) {
    ## removing margin of error variables, if included
    variables = variables[!stringr::str_detect(variables, "_M$")]

    # the names vector of variable codes and corresponding semantic names
    variables_with_names = list_acs_variables(year = year)

    existing_variables = data.frame(
      variable_name = names(variables_with_names) %>% stringr::str_remove("_$"),
      definition = variables_with_names %>% as.character) %>%
      dplyr::mutate(
        domain = dplyr::case_when(
          stringr::str_detect(definition, "B01003") ~ "General",
          stringr::str_detect(definition, "B19058|B22003|B1908|B19013|B17020|B25074|B25105") ~
            "Income, Poverty, Public Assistance",
          stringr::str_detect(definition, "B03002|B01001|B18101|B16005") ~ "Demographics",
          stringr::str_detect(definition, "B25003|B25014|B25032|B25074|B25105|B25010|B25034") ~
            "Housing",
          stringr::str_detect(definition, "B08301") ~ "Transportation",
          stringr::str_detect(definition, "B15003|B14007") ~ "Education",
          stringr::str_detect(definition, "B23025") ~ "Employment",
          stringr::str_detect(definition, "B27011") ~ "Health",
          T ~ NA_character_),
        variable_type = "original") %>%
      ## household_income_by_gross_rent.* variables are duplicated -- this is a temporary
      ## fix to an underlying issue
      dplyr::distinct()

    calculated_variables = data.frame(
      variable_name = variables[!(variables %in% (names(variables_with_names) %>% stringr::str_remove("_$")))]) %>%
        dplyr::mutate(
          definition = dplyr::case_when(
            variable_name == "GEOID" ~ "A unique identifier for the geography (from the Census Bureau API).",
            variable_name == "NAME" ~ "The name of the geography (from the Census Bureau API).",
            variable_name == "data_source_year" ~ "The end year of the five-year ACS period from which data were queried.",
            stringr::str_detect(variable_name, "snap_received") ~
              "snap_received / snap_universe. universe = all households.",
            stringr::str_detect(variable_name, "public_assistance_received") ~
              "public_assistance_received / public_assistance_universe. universe = all households.",
            stringr::str_detect(variable_name, "federal_poverty_limit_below") ~
              "federal_poverty_limit_below_[race_group] / federal_poverty_limit_below_[race_group]_universe. universe = all households.",
            stringr::str_detect(variable_name, "cost_burdened") ~
              "sum of household_income_by_gross_rent_as_a_percentage_of_household_income_in_the_past_12_months* estimates within the specified income and rent-share thresholds, as applicable, divided by the sum of the corresponding income estimates (omitting 'not computed' estimates). universe = all households with housing costs.",
            stringr::str_detect(variable_name, "^race_(nonhispanic|hispanic)") ~
              "race_[ethnicity]_[race_group] / race_universe. universe = all individuals.",
            stringr::str_detect(variable_name, "race_personofcolor_percent") ~
              "1 minus the value of race_nonhispanic_white_alone_percent. universe = all individuals.",
            stringr::str_detect(variable_name, "sex_female_percent") ~
              "sex_by_age_female / sex_by_age_universe. universe = all individuals.",
            stringr::str_detect(variable_name, "sex_male_percent") ~
              "sex_by_age_male / sex_by_age_universe. universe = all individuals.",
            stringr::str_detect(variable_name, "sex_by_age_female") ~
              "sum of female and male estimates by age group / sex_by_age_universe. universe = all individuals.",
            stringr::str_detect(variable_name, "disability_percent") ~
              "sum of sex_by_age_by_disability_status_[sex]_[age]_with_a_disability/ sex_by_age_by_disability_status_universe. universe = all individuals.",
            stringr::str_detect(variable_name, "tenure_renteroccupied_percent") ~
              "tenure_renter_occupied / tenure_universe. universe = all households.",
            stringr::str_detect(variable_name, "tenure_owneroccupied_percent") ~
              "tenure_owner_occupied / tenure_universe. universe = all  households.",
            stringr::str_detect(variable_name, "tenure_renter_occupied|tenure_owner_occupied") ~
              "tenure_[tenure_status]_occupied / tenure_universe. universe = all households.",
            stringr::str_detect(variable_name, "tenure.*householder.*occupied") ~
              "tenure_[race_group]_[tenure_status]_occupied / tenure_[race_group]_universe. universe = all households.",
            stringr::str_detect(variable_name, "overcrowding") ~
              "sum of estimates of households above the specified people-per-room (ppr) threshold (by tenure, as applicable) / tenure_by_occupants_per_room (by tenure, as applicable). universe = all households.",
            stringr::str_detect(variable_name, "year_structure_built.*since") ~
              "sum of estimates of housing units built since specified year / year_structure_built_universe . universe = all housing units.",
            stringr::str_detect(variable_name, "year_structure_built") ~
              "year_structure_built_built_[date_range] / year_structure_built_universe . universe = all housing units.",
            stringr::str_detect(variable_name,"means_of_transportation_work_public_transit_percent") ~
              "means of transportation to work via all public transit modes (excluding taxicab) / means_of_transportation_work_universe minus means_of_transportation_work_from_home. universe = all employed households.",
            stringr::str_detect(variable_name,"means_of_transportation_work_bicycle_or_walked_percent") ~
              "means of transportation to work via walking or biking / means_of_transportation_work_universe minus means_of_transportation_work_from_home. universe = all employed households.",
            stringr::str_detect(variable_name,"means_of_transportation_work_motor_vehicle_percent") ~
              "means of transportation to work via car, truck, van, taxicab, or motorcycle / means_of_transportation_work_universe minus means_of_transportation_work_from_home. universe = all employed households.",
            stringr::str_detect(variable_name,"means_of_transportation_work") ~
              "means_of_transportation_work_[transportation_mode] / means_of_transportation_work_universe minus means_of_transportation_work_from_home. universe = all employed households.",
            stringr::str_detect(variable_name,"educational_attainment_highschool_none_percent") ~
              "sum of educational_attainment estimates through eighth grade / educational_attainment_universe. universe = individuals age 25 and above.",
            stringr::str_detect(variable_name,"educational_attainment_highschool_nodiploma_percent") ~
              "sum of educational_attainment estimates through twelfth grade (not including diploma) / educational_attainment_universe. universe = individuals age 25 and above.",
            stringr::str_detect(variable_name,"educational_attainment_ged_percent") ~
              "educational_attainment_ged / educational_attainment_universe. universe = individuals age 25 and above.",
            stringr::str_detect(variable_name,"educational_attainment_highschool_diploma_percent") ~
              "educational_attainment_highschool_diploma / educational_attainment_universe. universe = individuals age 25 and above.",
            stringr::str_detect(variable_name,"educational_attainment_college_some_percent") ~
              "educational_attainment_some_college / educational_attainment_universe. universe = individuals age 25 and above.",
            stringr::str_detect(variable_name,"educational_attainment_degree_associate_percent") ~
              "educational_attainment_associates_degree / educational_attainment_universe. universe = individuals age 25 and above.",
            stringr::str_detect(variable_name,"educational_attainment_degree_bachelors_percent") ~
              "educational_attainment_bachelors_degree / educational_attainment_universe. universe = individuals age 25 and above.",
            stringr::str_detect(variable_name,"educational_attainment_degree_morethanbachelors_percent") ~
              "sum of educational_attainment for masters, professional, or doctorate / educational_attainment_universe. universe = individuals age 25 and above.",
            stringr::str_detect(variable_name,"educational_enrollment_grades_1thru12_percent") ~
              "school_enrollment_universe minus all enumerated enrollment categories (including not enrolled) / school_enrollment_universe. universe = all individuals.",
            stringr::str_detect(variable_name,"school_enrollment.") ~
              "school_enrollment_[enrollment_type] / school_enrollment_universe. universe = .",
            stringr::str_detect(variable_name,"nativity") ~
              "nativity_by_language_spoken_at_home_by_ability_speak_english_for_the_population_5_years_over_[native_status] / nativity_by_language_spoken_at_home_by_ability_speak_english_for_the_population_5_years_over_universe. universe = all individuals over age of 5.",
            stringr::str_detect(variable_name,"ability_speak_english") ~
              "sum of estimates of only speak english and speak english very well / nativity_by_language_spoken_at_home_by_ability_speak_english_for_the_population_5_years_over_universe. universe = all individuals over age of 5.",
            stringr::str_detect(variable_name,"employment") ~
              "employment_civilian_labor_force_employed / employment_civilian_labor_force_universe. universe = all individuals in labor force.",
            stringr::str_detect(variable_name,"health_insurance_coverage_status_covered_percent") ~
              "sum of estimates of individuals with health insurance coverage / health_insurance_coverage_status_type_by_employment_status_universe. universe = all individuals.",
            stringr::str_detect(variable_name,"health_insurance_coverage_status_notcovered_percent") ~
              "1 - health_insurance_coverage_status_covered_percent. universe = all individuals.",
            stringr::str_detect(variable_name,"health_insurance_coverage_status_covered_employed_percent") ~
              "sum of estimates of employed individuals with health insurance coverage / health_insurance_coverage_status_type_by_employment_status_in_labor_force. universe = all individuals in the labor force.",
            stringr::str_detect(variable_name,"health_insurance_coverage_status_covered_unemployed_percent") ~
              "sum of estimates of unemployed individuals with health insurance coverage / health_insurance_coverage_status_type_by_employment_status_in_labor_force. universe = all individuals in the labor force.",
            stringr::str_detect(variable_name, "tenure_by_occupants_per_room_renter_occupied_owner_occupied$") ~
              "the universe for all renter- and owner-occupied households with occupancy-per-room estimates.",
            stringr::str_detect(variable_name, "tenure.*occupants_per_room.*renter.*owner_occupied$") ~
              "sum of estimates of renter- and owner-occupied households at the given occupants-per-room occupancy range.",
            stringr::str_detect(variable_name, "tenure_by_units_in_structure_renter_occupied_housing_units_owner_occupied$") ~
              "the universe for all renter- and owner-occupied households with units-in-structure estimates.",
            stringr::str_detect(variable_name, "tenure_by_units_in_structure_renter_occupied_housing_units.*([0-9]|mobile|boat).*owner_occupied$") ~
              "sum of estimates of renter- and owner-occupied households at the given units-in-structure range.",
            stringr::str_detect(variable_name, "tenure.*occupants_per_room.*renter.*owner_occupied.*percent") ~
              "sum of estimates of renter- and owner-occupied households at the given occupants-per-room occupancy range / tenure_by_occupants_per_room_renter_occupied_owner_occupied.",
            stringr::str_detect(variable_name, "tenure_by_units_in_structure_renter_occupied_housing_units.*([0-9]|mobile|boat).*owner_occupied.*percent") ~
              "sum of estimates of renter- and owner-occupied households at the given units-in-structure range / tenure_by_units_in_structure_renter_occupied_housing_units_owner_occupied.",
            stringr::str_detect(variable_name, "tenure_by_units_in_structure.*") ~
              "tenure_by_units_in_structure_[occupancy type]_[unit count] / tenure_by_units_in_structure_[occupancy type universe]",
            stringr::str_detect(variable_name, "tenure_by_occupants_per_room") ~
              "tenure_by_occupants_per_room_[occupancy type]_[occupants per room range] / tenure_by_occupants_per_room_[occupancy type universe]",
            stringr::str_detect(variable_name, "means_transportation_work.*percent") ~
              "means_transportation_work_[transportation types] / means_transportation_work_universe"),
        domain = dplyr::case_when(
          stringr::str_detect(variable_name, "snap|public_assistance|poverty|cost_burden") ~
            "Income, Poverty, Public Assistance",
          stringr::str_detect(variable_name, "tenure|overcrowding|built") ~ "Housing",
          stringr::str_detect(variable_name, "transportation") ~ "Transportation",
          stringr::str_detect(variable_name, "school_enrollment|education") ~ "Education",
          stringr::str_detect(variable_name, "employment") ~ "Employment",
          stringr::str_detect(variable_name, "health_insurance") ~ "Health",
          stringr::str_detect(variable_name, "race|sex|disability|age|english|nativity") ~
            "Demographics",
          variable_name %in% c("GEOID", "NAME", "data_source_year") ~ "Metadata",
          T ~ NA_character_),
        variable_type = "calculated") %>%
      dplyr::filter(!stringr::str_detect(variable_name, "count_estimate"))

    full_codebook = dplyr::bind_rows(
      existing_variables,
      calculated_variables) %>%
      dplyr::mutate(variable_definition_year = year)

    return(full_codebook)
  }

  complete_codebook = purrr::map_dfr(
      years,
      ~ generate_single_year_codebook(.x, variables = variables)) %>%
    dplyr::arrange(domain, variable_type) %>%
    dplyr::group_by(variable_name, definition, domain, variable_type) %>%
    ## where all other columns are the same, retain just one entry for each variable
    ## and provide all years (comma-separated) in the variable_definition_year column
    dplyr::summarise(variable_definition_year = paste(variable_definition_year, collapse = ", ")) %>%
    dplyr::ungroup()

  missing_metadata = complete_codebook %>%
    dplyr::summarise(dplyr::across(dplyr::everything(), ~ sum(is.na(.x)))) %>%
    tidyr::pivot_longer(dplyr::everything()) %>%
    dplyr::summarize(max = max(value)) %>%
    dplyr::pull()

  if (missing_metadata > 0) {
    warning(paste0(missing_metadata, " variable(s) in the codebook are missing information.\n",
        "Run [codebook] %>% filter(is.na(definition)) to identify missingness."))}

  return(complete_codebook)
}

utils::globalVariables(c(
  "variable_name", "domain", "variable_type", "definition",
  "variable_definition_year", "value"))
